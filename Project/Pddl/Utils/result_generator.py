from typing import Dict, List
from Project.Simplify.components import Graph
from Project.Traci.scenarios.generators import RoutesGenerator
from Project.Utils.constants import file_exists, dir_exist, PATH
from os import listdir
import re


class ResultGenerator:
    """ Class which converts files generated by planner to simulation ('.sumocfg') """
    def __init__(self, graph: Graph, route_generator: RoutesGenerator):
        self.graph: Graph = graph
        self.route_generator: RoutesGenerator = route_generator


    def parse_result(self, scenario_name: str, result_name: str) -> Dict[str, str]:
        """
        :param scenario_name:
        :param result_name:
        :return:
        """
        # Mapping of cars to their entire path
        paths: Dict[str, str] = {}
        # Checks
        if not dir_exist(PATH.TRACI_SCENARIOS.format(scenario_name)):
            return paths
        elif not file_exists(PATH.TRACI_SCENARIOS_RESULTS.format(scenario_name, result_name)):
            return paths

        # Parse the result file
        with open(PATH.TRACI_SCENARIOS_RESULTS.format(scenario_name, result_name), "r") as file:
            # Find vehicle, road (expecting all actions correspond to vehicle using such road)
            # Expecting to find only one vehicle in format: v(number)
            # Expecting to find only one road in format: r(number)
            car_id: str
            route_id: int
            for line in file:
                result: List[str] = re.findall(r"[v|r]\d+", line)
                if len(result) != 2:
                    print(f"Unknown line in pddl file: {line}")
                    print(f"Expecting to find pattern: 'v(number)' 'r(number)'")
                    print(f"Corresponding to vehicle using road (exactly 1 vehicle and 1 road)!")
                    return {}
                # Sorted alphabetically in reverse -> [vehicle, road, junction\s]
                result.sort(key=lambda x: x[0], reverse=True)
                car_id: str = result[0]
                route_id: int = int(result[1][1:])
                if car_id not in paths:
                    paths[car_id] = ""
                paths[car_id] += (" ".join(self.graph.skeleton.routes[route_id].get_edge_ids()) + " ")
        return paths

    def results_to_scenario(self, scenario_name: str) -> None:
        """
        :param scenario_name:
        :return:
        """
        unique_routes: Dict[str, str] = {}
        vehicles: Dict[str, str] = {}
        root = self.route_generator.root
        for xml_route in root.findall("route"):
            root.remove(xml_route)
        # Cars and their routes
        for i in range(interval):  # 15
            file: str = f"result{i * 20}_{i * 20 + 20}.1"
            paths: Dict[str, str] = self.parse_result(scenario_name, file)
            for vehicle_id, route_edges in paths.items():
                route_edges = route_edges.rstrip()
                if route_edges not in unique_routes:
                    route: Route = Route(0, [self.graph.skeleton.edges[edge_id] for edge_id in route_edges.split()])
                    tmp = route.to_xml()
                    root.insert(0, ET.Element(tmp.tag, tmp.attrib))
                    unique_routes[route_edges] = route.attributes["id"]
                vehicles[vehicle_id] = unique_routes[route_edges]
        # Change cars routes
        for xml_vehicle in root.findall("vehicle"):
            xml_vehicle.attrib["route"] = vehicles[xml_vehicle.attrib["id"]]
        self.route_generator.save(PATH.TRACI_SCENARIOS.format(scenario_name)+"/routes1.ruo.xml")


# For testing purposes
if __name__ == "__main__":
    temp: str = "(drive-to-light v100 j37 r65 j41 j91 use0 use1)"
    result = re.findall(r"[v|r]\d+", temp)
    # Sorted alphabetically in reverse -> [vehicle, road, junction\s]
    print(result)
