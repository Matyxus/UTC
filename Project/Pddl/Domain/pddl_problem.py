from typing import List


class PddlProblem:
    """ Class holding attributes of pddl problem """
    def __init__(self):
        print("Creating pddl problem class")
        # General pddl representation of problem (also used for vehicles)
        self.attributes: dict = {
            "problem": None,  # Problem is of type string (problem_name of pddl)
            "domain": None,  # Domain is of type string (:domain of pddl)
            "comments": [],  # List of comments (can be added without ';')
            "object": {},  # {object_group : [object_id, ..], ...} (:objects of pddl)
            "init": [],  # [(predicate1), ...] (:init of pddl)
            "goal": [],  # [(predicate1), ...] (:goal of pddl)
            "metric": None  # Metric is of type string (:metric of pddl)
        }
        # Pddl representation of road network,
        # separate dict since network many not change during simulation
        self.network_pddl: dict = {}  # Generated by 'to_pddl' graph module
        # Pddl representation of vehicles
        self.vehicles_pddl: dict = {}
    # ------------------------------- Getters for string representation -------------------------------

    def get_problem(self) -> str:
        """
        :return: pddl representation of 'problem' as string (with newline)
        """
        return f"(problem {self.attributes['problem']})\n"

    def get_domain(self) -> str:
        """
        :return: pddl representation of 'domain' as string (with newline)
        """
        return f"(:domain {self.attributes['domain']})\n"

    def get_comments(self) -> str:
        """
        :return: pddl comment (; will be added to front)
        """
        ret_val: str = ""
        for comment in self.attributes["comments"]:
            ret_val += (";" + comment)
        return ret_val

    def get_objects(self) -> str:
        """
        :return: pddl representation of ':objects' as string (with newline)
        """
        ret_val: str = "(:objects\n"
        mappings: List[dict] = [self.attributes]
        if "object" in self.network_pddl:
            mappings.append(self.network_pddl)
        if "object" in self.vehicles_pddl:
            mappings.append(self.vehicles_pddl)
        for mapping in mappings:

            for object_group, objects in mapping["object"].items():
                ret_val += (" ".join(objects) + f" - {object_group}\n")
        return ret_val + ")\n"

    def get_init(self) -> str:
        """
        :return: pddl representation of ':init' as string (with newline)
        """
        ret_val: str = "(:init\n"
        mappings: List[dict] = [self.attributes]
        if "init" in self.network_pddl:
            mappings.append(self.network_pddl)
        if "init" in self.vehicles_pddl:
            mappings.append(self.vehicles_pddl)
        for mapping in mappings:
            for predicate in mapping["init"]:
                ret_val += (predicate + "\n")
        return ret_val + ")\n"

    def get_goal(self) -> str:
        """
        :return: pddl representation of ':goal' as string (with newline)
        """
        ret_val: str = "(:goal (and\n"
        mappings: List[dict] = [self.attributes]
        if "goal" in self.vehicles_pddl:
            mappings.append(self.vehicles_pddl)
        for mapping in mappings:
            for predicate in mapping["goal"]:
                ret_val += (predicate + "\n")
        return ret_val + "))\n"

    def get_metric(self) -> str:
        """
        :return: pddl representation of ':metric' as string (with newline)
        """
        return f"(:metric {self.attributes['metric']})\n"

    def get_pddl_string(self) -> str:
        """
        :return: entire pddl problem file as string
        """
        ret_val: str = f"(define\n"
        ret_val += self.get_problem() + self.get_domain()
        ret_val += self.get_objects() + self.get_init()
        ret_val += self.get_goal() + self.get_metric()
        return ret_val + ")"
