from utc.src.graph.components import Graph, Skeleton
from utc.src.pddl.pddl_problem.pddl_problem import PddlProblem
from utc.src.pddl.pddl_problem.pddl_result import PddlResult
from utc.src.simulator.scenario import Scenario
from utc.src.file_system import MyFile, DefaultDir, MyDirectory, FilePaths, DirPaths, FileExtension
from utc.src.file_system.directory_types import ScenarioDir
from utc.src.ui import UserInterface, Command
from typing import List, Optional


class PddlLauncher(UserInterface):
    """ Class that implements interface methods for generating pddl problems/results """

    def __init__(self, log_commands: bool = True):
        super().__init__("PddlLauncher", log_commands)
        # -------------- Pddl --------------
        self.pddl_problem: Optional[PddlProblem] = None
        self.pddl_result: Optional[PddlResult] = None
        # Scenario
        self.scenario_dir: Optional[ScenarioDir] = None
        self.scenario: Optional[Scenario] = None
        self.graph: Optional[Graph] = None

    # ---------------------------------- Commands ----------------------------------

    def initialize_commands(self) -> None:
        super().initialize_commands()
        self.user_input.add_command([Command("initialize", self.initialize_command)])

    @UserInterface.log_command
    def initialize_command(self, new_scenario: str, scenario: str, network: str = "default") -> bool:
        """
        Initializes environment for generating pddl problem/result files and
        conversion of result files to scenarios, unlocks commands

        :param new_scenario: name of newly generated scenario and its associated folders/files,
        saved in parameter 'scenario' directory
        :param scenario: name of scenario to load (folder name and associated files,
        generated by ScenarioMain class)
        :param network: name of network, if default, will be extracted from ".sumocfg" file (scenario)
        :return: None
        """
        self.scenario = Scenario(new_scenario, scenario_folder=scenario, create_new=False)
        if self.scenario.exists(message=False):
            print(f"Scenario in folder: '{scenario}' named: {new_scenario} already exists!")
            self.scenario = None
            return False
        # Load '.sumocfg' and '.rou.xml' from original scenario
        self.scenario.routes_file.load(FilePaths.SCENARIO_ROUTES.format(scenario, scenario))
        self.scenario.config_file.load(FilePaths.SCENARIO_CONFIG.format(scenario, scenario))
        if not self.scenario.exists(message=True):
            print(f"Unable to find routes and/or config files!")
            return False
        self.scenario_dir = ScenarioDir(scenario)
        if network == "default":
            network = self.scenario.config_file.get_network()
        # Check network existence (prioritize networks in scenario)
        if MyFile.file_exists(FilePaths.SCENARIO_MAP.format(scenario, network), message=False):
            network = FilePaths.SCENARIO_MAP.format(scenario, network)
        elif MyFile.file_exists(FilePaths.MAP_SUMO.format(network), message=False):
            network = FilePaths.MAP_SUMO.format(network)
        else:
            print(
                f"Unable to find network: '{network}' "
                f"in either of directories: {FilePaths.MAP_SUMO.format(network)}, "
                f"{FilePaths.SCENARIO_MAP.format(scenario, network)}"
            )
            return False
        self.graph = Graph(Skeleton())
        # Error at loading network
        if not self.graph.loader.load_map(network):
            return False
        self.graph.simplify.simplify_graph()
        # Unlock commands for generating pddl files and scenario
        if self.user_input is not None:
            self.user_input.add_command([
                Command("generate_problems", self.generate_problems_command),
                Command("generate_results", self.generate_results_command),
                Command("generate_scenario", self.generate_scenario_command),
                Command("plan_scenario", self.plan_scenario_command)
            ])
        return True

    # -------------------------------------------- Problem --------------------------------------------

    def generate_problems_command(self, domain: str, *args, **kwargs) -> None:
        """
        Generates ".pddl" problem files corresponding to loaded scenario,
        resulting files will be named: "new_scenario_problem[suffix].pddl",
        where suffix is added by Subclass

        :param domain: name of pddl domain (must be in /utc/data/domains)
        :param args: additional arguments
        :param kwargs: additional arguments
        :return: None
        """
        raise NotImplementedError("Method 'generate_problems' must be implemented by children of PddlLauncher")

    # -------------------------------------------- Result --------------------------------------------

    def generate_results_command(
            self, planner: str, domain: str,
            timeout: int = 30, thread_count: int = 1,
            *args, **kwargs
            ) -> bool:
        """
        Generates ".pddl" results files to loaded scenario,
        the generated result files will be named: "new_scenario_result[suffix].pddl,
        where suffix is added by Subclass

        :param planner: name of planner to be used (must be defined in /utc/src/util/constants -> PLANNERS)
        :param domain: name of pddl domain (must be in /utc/data/domains)
        :param timeout: seconds given to planner execution
        :param thread_count: number of parallel planner calls (default one -> current process)
        :param args: additional arguments
        :param kwargs: additional arguments
        :return: true on success, false otherwise
        """
        raise NotImplementedError("Method 'generate_results' must be implemented by children of PddlLauncher")

    def generate_result_command(
            self, problem: str, planner: str,
            domain: str, out_dir: DefaultDir,
            timeout: int = 30, *args, **kwargs
            ) -> bool:
        """
        Generates single ".pddl" result files from given problem file name,
        the generated result file will be named: "new_scenario_result[suffix].pddl,
        where suffix is added by Subclass

        :param problem: name of problem file (must be in /utc/data/scenarios/problems/new_scenario)
        :param planner: name of planner to be used (must be defined in /utc/src/util/constants -> PLANNERS)
        :param domain: name of pddl domain (must be in /utc/data/domains)
        :param timeout: seconds given to planner execution
        :param out_dir: directory to which the planner will output its files
        :param args: additional arguments
        :param kwargs: additional arguments
        :return: true on success, false otherwise
        """
        raise NotImplementedError("Method 'generate_result' must be implemented by children of PddlLauncher")

    # -------------------------------------------- Scenario --------------------------------------------

    def generate_scenario_command(self, generate_best: bool = True, keep_files: bool = True, *args, **kwargs) -> bool:
        """
        Generates new scenario from ".pddl" result files

        :param generate_best: true if only the best scenario (for multiple result files
        extensions should be generated, (when alphabetically sorted)), default true
        :param keep_files: if pddl problem/result files should be kept (default true)
        :param args: additional arguments
        :param kwargs: additional arguments
        :return: true on success, false otherwise
        """
        raise NotImplementedError("Method 'generate_scenario' must be implemented by children of PddlLauncher")

    def plan_scenario_command(self, domain: str, planner: str, timeout: int = 30, *args, **kwargs) -> None:
        """
        Plans scenario "on the go" during the simulation (displayed on SumoGUI), automatically
        generates statistics files

        :param domain: name of pddl domain (must be in /utc/data/domains)
        :param planner: name of planner to be used (must be defined in /utc/src/util/constants -> PLANNERS)
        :param timeout: seconds given to planner execution
        :param args: additional arguments
        :param kwargs: additional arguments
        :return: None
        """
        raise NotImplementedError("Method 'plan_scenario' must be implemented by children of PddlLauncher")

    # ------------------------------------------------ Utils -----------------------------------------------

    def check_pddl_extension(self, dir_path: str) -> None:
        """
        Checks if files in directory end with ".pddl" extension,
        if not, renames such files so that their extension
        ends with ".pddl"

        :param dir_path: path to directory
        :return: None
        """
        files: Optional[List[str]] = MyDirectory.list_directory(dir_path)
        if files is None:
            print(f"Invalid directory: {dir_path} passed to method: 'check_pddl_extension'")
            return
        for file in files:
            if file.endswith(".pddl"):
                continue
            # Add absolute path
            file = dir_path + "/" + file
            # If ".pddl" extension is not last, remove it
            new_file = file.replace(FileExtension.PDDL, "") + FileExtension.PDDL
            if not MyFile.rename_file(file, new_file):
                continue

    def is_initialized(self) -> bool:
        """
        :return: True if Class was initialized with "initialize" method, false otherwise
        """
        return not ((self.scenario is None) and (self.graph is None) and (self.scenario_dir is None))
